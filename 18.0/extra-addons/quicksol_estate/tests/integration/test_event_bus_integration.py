# -*- coding: utf-8 -*-
"""
Integration Tests for EventBus - Real Database + Observers

These tests use TransactionCase and verify EventBus functionality with:
- Real database persistence
- Real observer registration
- Actual Odoo environment

Run: docker compose run --rm odoo odoo --test-enable --test-tags=quicksol_estate
"""

from odoo.tests.common import TransactionCase
from odoo.exceptions import ValidationError


class TestEventBusIntegration(TransactionCase):
    """Integration tests for EventBus with real database"""
    
    @classmethod
    def setUpClass(cls):
        """Set up test environment once for all tests"""
        super(TestEventBusIntegration, cls).setUpClass()
        cls.EventBus = cls.env['event.bus']
        cls.Property = cls.env['real.estate.property']
        
        # Create test company
        cls.test_company = cls.env['res.company'].create({
            'name': 'Test Real Estate Company',
        })
        
        # Create test property type
        cls.property_type = cls.env['real.estate.property.type'].create({
            'name': 'Residential',
        })
    
    def test_eventbus_singleton_instance(self):
        """Test that EventBus is accessible via self.env"""
        instance1 = self.env['quicksol.event.bus']
        instance2 = self.env['quicksol.event.bus']
        
        self.assertEqual(instance1._name, instance2._name)
        self.assertEqual(instance1._name, 'quicksol.event.bus')
    
    def test_eventbus_emit_sync(self):
        """Test that EventBus.emit() triggers registered observers synchronously"""
        # Create a property to trigger property.before_create event
        property_data = {
            'name': 'Test Property for EventBus',
            'expected_price': 100000,
            'property_type_id': self.property_type.id,
            'company_id': self.test_company.id,
        }
        
        # This should trigger property.before_create event via emit()
        new_property = self.Property.create(property_data)
        
        # Verify property was created (event didn't block creation)
        self.assertTrue(new_property.id)
        self.assertEqual(new_property.name, 'Test Property for EventBus')
        
        # Verify reference_code was auto-generated by observer or model
        self.assertIsNotNone(new_property.reference_code)
    
    def test_eventbus_emit_with_force_sync(self):
        """Test that emit_async with force_sync=True executes synchronously"""
        event_bus = self.env['quicksol.event.bus']
        
        # Create test data for property.created event
        test_property = self.Property.create({
            'name': 'Async Test Property',
            'expected_price': 150000,
            'property_type_id': self.property_type.id,
            'company_id': self.test_company.id,
        })
        
        # Emit async event with force_sync (should execute immediately)
        result = event_bus.emit_async('property.created', test_property, force_sync=True)
        
        # With force_sync=True, result should be True (not a task_id)
        self.assertTrue(result)
    
    def test_eventbus_observers_registered(self):
        """Test that observers are properly registered in EventBus"""
        event_bus = self.EventBus.get_instance()
        
        # Verify observers dict exists and has registrations
        self.assertIsNotNone(event_bus.observers)
        self.assertIsInstance(event_bus.observers, dict)
        
        # Check that critical events have observers registered
        expected_events = [
            'property.before_create',
            'property.created',
            'user.before_create',
            'user.before_write',
        ]
        
        for event_name in expected_events:
            if event_name in event_bus.observers:
                observers = event_bus.observers[event_name]
                self.assertGreater(len(observers), 0, 
                                 f"Event '{event_name}' should have at least one observer")
    
    def test_async_event_queuing(self):
        """Test that async events are queued to RabbitMQ when force_sync=False"""
        event_bus = self.env['quicksol.event.bus']
        
        # Create test property for event
        test_property = self.Property.create({
            'name': 'Async Queue Test Property',
            'expected_price': 200000,
            'property_type_id': self.property_type.id,
            'company_id': self.test_company.id,
        })
        
        # Emit async event WITHOUT force_sync (should queue to RabbitMQ)
        try:
            result = event_bus.emit_async('property.created', test_property, force_sync=False)
            
            # Result should be a task_id (string) when queued successfully
            # Or True if RabbitMQ not available (fallback to sync)
            self.assertTrue(result is True or isinstance(result, str))
        except Exception as e:
            # If RabbitMQ is not running, this is expected in test environment
            self.assertIn('RabbitMQ', str(e) or 'Connection refused', str(e))
